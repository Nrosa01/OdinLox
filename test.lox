// Declaration
var a = 5;

// Built-in function
print a; 

// Control flow
if (a < 2) {
    print "It's minor";
} else {
    print "It's bigger";
}

// Loops
var a = 1;
while (a < 10) {
  print a;
  a = a + 1;
}

for(var i = 8; i > 0; i = i - 1) {
    print i;
}

fun areWeHavingItYet() {
  print "Yes we are!";
}

// Proof that functions are first-class citizen
print areWeHavingItYet;

// Function call (implicit return is nil)
areWeHavingItYet();

// Recursion
fun fib(n) {
  if (n < 2) return n;
  return fib(n - 2) + fib(n - 1);
}

// Native functions* (clock)
var start = clock();
print fib(5);
// print fib(35);
print clock() - start;

// Addendum: The difference between native and built-in functions, is that native functions
// are treated like user declared functions. That means you can do this
//      fun test() {
//      print "hola";
//      }
//      
//      clock = test;
//      
//      test();
//      clock();
//      
//      print test == clock; // This prints 'true'
//
// You can't do this with the built-in procedure 'print'. 
// In short, print is a language keyword same as if, var, while etc.

// Closures
fun outer() {
  var x = "value";
  fun middle() {
    fun inner() {
      print x;
    }

    print "create inner closure";
    return inner;
  }

  print "return from outer";
  return middle;
}

var mid = outer();
var in = mid();
in();


class Brioche {}
var a = Brioche();
print Brioche;
print a;

class Pair {}

var pair = Pair();
pair.first = 1;
pair.second = 2;
print pair.first + pair.second; // 3.

class Scone {
  topping(first, second) {
    print "scone with " + first + " and " + second;
  }
}

var scone = Scone();
scone.topping("berries", "cream");

class CoffeeMaker {
  init(coffee) {
    this.coffee = coffee;
  }

  brew() {
    print "Enjoy your cup of " + this.coffee;

    // No reusing the grounds!
    this.coffee = nil;
  }
}

var maker = CoffeeMaker("coffee and chicory");
maker.brew();
